// Generated by CoffeeScript 1.6.2
this.user = 'wiber';

this.recFrom = 'picture';

ConsoleMe.enabled = true;

Meteor.methods({
  "dummyInsert": function(args) {
    var one, two;

    if (!args) {
      args = user;
    }
    one = WI.insert({
      '_id': args
    });
    two = W.insert({
      '_id': args
    });
    return one;
  },
  "clearDb": function() {
    var one, two;

    one = W.remove({});
    two = WI.remove({});
    smite(one, two, 'clearDb buckle my boots', WI.find({}).count(), eval(s));
    return WI.findOne({});
  }
});

this.generateRecommend = function(i) {
  return {
    to: user + i,
    from: recFrom + i
  };
};

Meteor.startup(function() {
  var testing;

  if (Meteor.isClient) {
    testing = 0;
    Tinytest.addAsync('clear - ' + testing + ' call clearDb server clears db and W goes to 0 items', function(test, next) {
      return Meteor.call('clearDb', function(res, err) {
        var one;

        one = WI.find({}).count();
        test.equal(one, 0);
        return next();
      });
    });
    testing++;
    Tinytest.addAsync('clear - ' + testing + ' call clearDb server clears db and WI goes to 0 items', function(test, next) {
      var two;

      two = WI.find({}).count();
      test.equal(two, 0);
      return next();
    });
    testing++;
    Tinytest.add('insert - ' + testing + ' dummyInsert creates WI user object synced to client', function(test, next) {
      return Meteor.call('dummyInsert', user, function(res, err) {
        var userCreated;

        userCreated = WI.findOne({
          '_id': user
        });
        smite(userCreated, user);
        test.equal(userCreated._id, user);
        return next();
      });
    });
    testing++;
    Tinytest.addAsync('update - ' + testing + ' clientside update of WI should hook same inserted into W', function(test, next) {
      var rec;

      rec = generateRecommend(testing);
      connect(rec);
      return Tracker.autorun(function(computation) {
        var one;

        one = W.findOne({
          from: rec.from,
          to: rec.to
        });
        smite(rec, one, testing, 'testing inserted', eval(s));
        if (!!one) {
          test.equal(one.from, rec.from);
          return next();
        }
      });
    });
    testing++;
    Tinytest.addAsync('update - ' + testing + ' client WI.outbox -> server W -> client WI.inbox', function(test, next) {
      var rec;

      rec = generateRecommend(testing);
      connect(rec);
      return Tracker.autorun(function(computation) {
        var two;

        two = WI.findOne({
          _id: rec.to
        });
        smite(rec, two, testing, 'testing update outbox to inbox', eval(s));
        if (!!two.inbox) {
          test.equal(two.inbox[0].from, rec.from);
          return next();
        }
      });
    });
    testing++;
    return Tinytest.addAsync('feed - ' + testing + ' client WI.feed has ten dummy items hooked in after server sees feed field', function(test, next) {
      WI.update({
        _id: user
      }, {
        feed: 'nothing'
      });
      return Tracker.autorun(function(computation) {
        var feed;

        smite(feed = WI.find({
          _id: 'wiber'
        }).fetch()[0].feed, eval(s));
        if (!!feed[3].journey) {
          test.equal(Object.keys(feed[3].journey[0])[0], 'feed');
          return next();
        }
      });
    });
  }
});
